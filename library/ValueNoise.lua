---@meta

-- cspell:words noeased noisevals

-- ### Format example
--
-- For 2D or 3D value noise or value noise maps:
--
-- ```lua
-- np_terrain = {
--     offset = 0,
--     scale = 1,
--     spread = {x = 500, y = 500, z = 500},
--     seed = 571347,
--     octaves = 5,
--     persistence = 0.63,
--     lacunarity = 2.0,
--     flags = "defaults, absvalue",
-- }
-- ```
--
-- For 2D noise the Z component of `spread` is still defined but is ignored.
-- A single noise parameter table can be used for 2D or 3D noise.
---@class NoiseParams
--[[
After the multiplication by `scale` this is added to the result and is the final
step in creating the noise value.
Can be positive or negative.
]]
---@field offset number
--Once all octaves have been combined, the result is multiplied by this.
--Can be positive or negative.
---@field scale number
-- For octave1, this is roughly the change of input value needed for a very large
-- variation in the noise value generated by octave1. It is almost like a
-- 'wavelength' for the wavy noise variation.
-- Each additional octave has a 'wavelength' that is smaller than the previous
-- octave, to create finer detail. `spread` will therefore roughly be the typical
-- size of the largest structures in the final noise variation.
--
-- `spread` is a vector with values for x, y, z to allow the noise variation to be
-- stretched or compressed in the desired axes.
-- Values are positive numbers.
---@field spread vector
-- This is a whole number that determines the entire pattern of the noise
-- variation. Altering it enables different noise patterns to be created.
-- With other parameters equal, different seeds produce different noise patterns
-- and identical seeds produce identical noise patterns.
--
-- For this parameter you can randomly choose any whole number. Usually it is
-- preferable for this to be different from other seeds, but sometimes it is useful
-- to be able to create identical noise patterns.
--
-- In some noise APIs the world seed is added to the seed specified in noise
-- parameters. This is done to make the resulting noise pattern vary in different
-- worlds, and be 'world-specific'.
---@field seed number
-- The number of simple noise generators that are combined.
-- A whole number, 1 or more.
-- Each additional octave adds finer detail to the noise but also increases the
-- noise calculation load.
-- 3 is a typical minimum for a high quality, complex and natural-looking noise
-- variation. 1 octave has a slight 'gridlike' appearance.
--
-- Choose the number of octaves according to the `spread` and `lacunarity`, and the
-- size of the finest detail you require. For example:
-- if `spread` is 512 nodes, `lacunarity` is 2.0 and finest detail required is 16
-- nodes, octaves will be 6 because the 'wavelengths' of the octaves will be
-- 512, 256, 128, 64, 32, 16 nodes.
-- Warning: If the 'wavelength' of any octave falls below 1 an error will occur.
---@field octaves integer
-- Each additional octave has an amplitude that is the amplitude of the previous
-- octave multiplied by `persistence`, to reduce the amplitude of finer details,
-- as is often helpful and natural to do so.
-- Since this controls the balance of fine detail to large-scale detail
-- `persistence` can be thought of as the 'roughness' of the noise.
--
-- A positive or negative non-zero number, often between 0.3 and 1.0.
-- A common medium value is 0.5, such that each octave has half the amplitude of
-- the previous octave.
-- This may need to be tuned when altering `lacunarity`; when doing so consider
-- that a common medium value is 1 / lacunarity.
--
-- Instead of `persistence`, the key `persist` may be used to the same effect.
---@field persistence number
-- Each additional octave has a 'wavelength' that is the 'wavelength' of the
-- previous octave multiplied by 1 / lacunarity, to create finer detail.
-- 'lacunarity' is often 2.0 so 'wavelength' often halves per octave.
--
-- A positive number no smaller than 1.0.
-- Values below 2.0 create higher quality noise at the expense of requiring more
-- octaves to cover a particular range of 'wavelengths'.
---@field lacunarity number
-- Leave this field unset for no special handling.
-- Currently supported are `defaults`, `eased` and `absvalue`:
---@field flags string?
-- Specify this if you would like to keep auto-selection of eased/not-eased while
-- specifying some other flags.
---| "defaults"
-- Maps noise gradient values onto a quintic S-curve before performing
-- interpolation. This results in smooth, rolling noise.
-- Disable this (`noeased`) for sharp-looking noise with a slightly gridded
-- appearance.
-- If no flags are specified (or defaults is), 2D noise is eased and 3D noise is
-- not eased.
-- Easing a 3D noise significantly increases the noise calculation load, so use
-- with restraint.
---| "eased"
-- The absolute value of each octave's noise variation is used when combining the
-- octaves. The final value noise variation is created as follows:
--
-- ```
-- noise = offset + scale * (abs(octave1) +
--                           abs(octave2) * persistence +
--                           abs(octave3) * persistence ^ 2 +
--                           abs(octave4) * persistence ^ 3 +
--                           ...)
-- ```
---| "absvalue"

-- * `core.get_value_noise(noiseparams)`
--     * Return world-specific value noise.
--     * The actual seed used is the noiseparams seed plus the world seed.
--     * **Important**: Requires the mapgen environment to be initalized, do not use at load time.

-- * `core.get_value_noise(noiseparams)`
--     * Return world-specific value noise.
--     * The actual seed used is the noiseparams seed plus the world seed.
--     * **Important**: Requires the mapgen environment to be initalized, do not use at load time.
---@param noiseparams NoiseParams
---@return ValueNoise
function core.get_value_noise(noiseparams) end

---@param noiseparams NoiseParams
---@return ValueNoise
function ValueNoise(noiseparams) end

---@deprecated
---@param noiseparams NoiseParams
---@return ValueNoise
function PerlinNoise(noiseparams) end

---@deprecated
---@param noiseparams NoiseParams
---@return ValueNoise
function core.get_perlin(noiseparams) end

---@param noiseparams NoiseParams
---@param size vector|{x:number,y:number}
---@return ValueNoiseMap
function core.get_value_noise_map(noiseparams, size) end

---@param noiseparams NoiseParams
---@param size vector|{x:number,y:number}
---@return ValueNoiseMap
function ValueNoiseMap(noiseparams, size) end

---@param noiseparams NoiseParams
---@param size vector|{x:number,y:number}
---@return ValueNoiseMap
function core.get_perlin_noise_map(noiseparams, size) end

---@param noiseparams NoiseParams
---@param size vector|{x:number,y:number}
---@return ValueNoiseMap
function PerlinNoiseMap(noiseparams, size) end

---@class ValueNoise
-- * `get_2d(pos)`: returns 2D noise value at `pos={x=,y=}`
---@field get_2d fun(self,pos:{x:number,y:number}):{x:number,y:number}
-- * `get_3d(pos)`: returns 3D noise value at `pos={x=,y=,z=}`
---@field get_3d fun(self,pos:vector):vector

---@class ValueNoiseMap
-- * `get_2d_map(pos)`: returns a `<size.x>` times `<size.y>` 2D array of 2D noise
--   with values starting at `pos={x=,y=}`
---@field get_2d_map fun(self,pos:{x:number,y:number}):number[][]
-- * `get_3d_map(pos)`: returns a `<size.x>` times `<size.y>` times `<size.z>`
--   3D array of 3D noise with values starting at `pos={x=,y=,z=}`.
---@field get_3d_map fun(self,pos:vector):number[][][]
-- * `get_2d_map_flat(pos, buffer)`: returns a flat `<size.x * size.y>` element
--   array of 2D noise with values starting at `pos={x=,y=}`
---@field get_2d_map_flat fun(self,pos:{x:number, y:number}, buffer:number[]?):number[]?
-- * `get_3d_map_flat(pos, buffer)`: Same as `get2dMap_flat`, but 3D noise
---@field get_3d_map_flat fun(self,pos:vector, buffer:number[]?):number[]?
-- * `calc_2d_map(pos)`: Calculates the 2d noise map starting at `pos`. The result
--   is stored internally.
---@field calc_2d_map fun(self,pos:{x:number,y:number})
-- * `calc_3d_map(pos)`: Calculates the 3d noise map starting at `pos`. The result
--   is stored internally.
---@field calc_3d_map fun(self,pos:vector)
-- * `get_map_slice(slice_offset, slice_size, buffer)`: In the form of an array,
--   returns a slice of the most recently computed noise results. The result slice
--   begins at coordinates `slice_offset` and takes a chunk of `slice_size`.
--   E.g., to grab a 2-slice high horizontal 2d plane of noise starting at buffer
--   offset `y = 20`:
--   ```lua
--   noisevals = noise:get_map_slice({y=20}, {y=2})
--   ```
--   It is important to note that `slice_offset` offset coordinates begin at 1,
--   and are relative to the starting position of the most recently calculated
--   noise.
--   To grab a single vertical column of noise starting at map coordinates
--   `x = 1023, y=1000, z = 1000`:
--   ```lua
--   noise:calc_3d_map({x=1000, y=1000, z=1000})
--   noisevals = noise:get_map_slice({x=24, z=1}, {x=1, z=1})
--   ```
---@field get_map_slice fun(slice_offset: {x:number?, y:number?, z:number?}, slice_size:{x:number?, y:number?, z:number?}, buffer: number[]?):number[]?
